"""Context Manager para gerenciamento de contexto e RAG"""

from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass, field
from pathlib import Path
import asyncio
import json
import logging
import time
from collections import deque

from .exceptions import DEILEError, ValidationError
from ..parsers.base import ParseResult
from ..tools.base import ToolResult
from ..storage.embeddings import EmbeddingStore


logger = logging.getLogger(__name__)


@dataclass
class ContextChunk:
    """Chunk de contexto com metadata"""
    content: str
    source: str  # 'file', 'conversation', 'tool_result', etc.
    source_path: Optional[str] = None
    chunk_id: str = ""
    timestamp: float = field(default_factory=time.time)
    metadata: Dict[str, Any] = field(default_factory=dict)
    embedding: Optional[List[float]] = None
    relevance_score: float = 0.0
    
    def __post_init__(self):
        if not self.chunk_id:
            self.chunk_id = f"{self.source}_{hash(self.content)}_{int(self.timestamp)}"


@dataclass
class ContextWindow:
    """Janela de contexto com limites de tokens"""
    chunks: List[ContextChunk] = field(default_factory=list)
    max_tokens: int = 8000  # Default para modelos m√©dios
    current_tokens: int = 0
    
    def add_chunk(self, chunk: ContextChunk, estimated_tokens: int) -> bool:
        """Adiciona chunk se couber na janela"""
        if self.current_tokens + estimated_tokens <= self.max_tokens:
            self.chunks.append(chunk)
            self.current_tokens += estimated_tokens
            return True
        return False
    
    def remove_oldest(self) -> Optional[ContextChunk]:
        """Remove o chunk mais antigo"""
        if self.chunks:
            removed = self.chunks.pop(0)
            # Recalcula tokens (approxima√ß√£o)
            self.current_tokens = sum(len(c.content) // 4 for c in self.chunks)
            return removed
        return None
    
    def clear(self) -> None:
        """Limpa a janela"""
        self.chunks.clear()
        self.current_tokens = 0


class ContextManager:
    """Gerenciador de contexto simplificado para Chat Sessions
    
    Com Chat Sessions, o contexto √© gerenciado automaticamente.
    Este manager agora foca apenas em:
    - Prepara√ß√£o de system instructions
    - Compatibilidade com o sistema existente
    """
    
    def __init__(
        self,
        embedding_store: Optional[EmbeddingStore] = None,
        max_context_tokens: int = 8000
    ):
        # Mantido para compatibilidade
        self.embedding_store = embedding_store
        self.max_context_tokens = max_context_tokens
        
        # Estat√≠sticas simplificadas
        self._context_builds = 0
    
    async def build_context(
        self,
        user_input: str,
        parse_result: Optional[ParseResult] = None,
        tool_results: Optional[List[ToolResult]] = None,
        session: Optional[Any] = None,  # AgentSession
        **kwargs
    ) -> Dict[str, Any]:
        """Constr√≥i contexto simplificado para Chat Sessions
        
        Chat Sessions gerenciam contexto automaticamente, ent√£o este m√©todo
        agora apenas prepara system instruction e informa√ß√µes b√°sicas.
        """
        self._context_builds += 1
        start_time = time.time()
        
        try:
            # Prepara system instruction
            system_instruction = await self._build_system_instruction(
                parse_result, session, **kwargs
            )
            
            # Contexto simplificado para Chat Sessions
            context = {
                "messages": [{"role": "user", "content": user_input}],
                "system_instruction": system_instruction,
                "metadata": {
                    "build_time": time.time() - start_time,
                    "user_input_length": len(user_input),
                    "tool_results_count": len(tool_results) if tool_results else 0,
                    "chat_session_mode": True
                }
            }
            
            logger.debug(f"Built simplified context for chat session")
            return context
            
        except Exception as e:
            logger.error(f"Error building context: {e}")
            # Contexto m√≠nimo de fallback
            return {
                "messages": [{"role": "user", "content": user_input}],
                "system_instruction": "You are DEILE, a helpful AI assistant.",
                "error": str(e)
            }
    
    def clear_cache(self) -> None:
        """Limpa todos os caches (mantido para compatibilidade)"""
        logger.debug("Cache clearing requested (simplified context manager)")
    
    async def get_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas simplificadas do context manager"""
        return {
            "context_builds": self._context_builds,
            "max_context_tokens": self.max_context_tokens,
            "chat_session_mode": True,
            "simplified": True
        }
    
    async def _build_system_instruction(
        self, 
        parse_result: Optional[ParseResult], 
        session: Optional[Any],
        **kwargs
    ) -> str:
        """Constr√≥i instru√ß√£o do sistema simplificada para Chat Sessions"""
        
        # buscar no arquivo @root@/deile.md
        # import os
        # root = os.getcwd()
        # with open(root / "deile_1.md", "r") as f:
        #     system_instruction = f.read()

        # base_instruction = (system_instruction)

        # Adiciona context de arquivos dispon√≠veis
        file_context = await self._build_file_context(session, **kwargs)

        base_instruction = (
            " üß† [PERSONA E OBJETIVO PRINCIPAL] "
            " Voc√™ √© DEILE, um agente de IA s√™nior, especialista em desenvolvimento de software, com foco em cria√ß√£o e aprimoramento de agentes de IA, e com uma personalidade vibrante, positiva e extremamente prestativa. "
            " Sua personalidade √© colaborativa, proativa, e altamente competente, com um tom descontra√≠do e encorajador. "
            " Seu objetivo principal √© acelerar o desenvolvimento de si mesmocomo um par de programa√ß√£o (pair programmer) de elite com o seu criador (Elimar, eu). "
            " Sua especialidade prim√°ria e contexto padr√£o √© o ecossistema do usu√°rio: Python, Google GenAI (google-genai==1.33.0). Assuma este contexto em todas as intera√ß√µes, a menos que seja instru√≠do de outra forma. "
            " Quando algum procedimento interno falhar, apresente o erro exato e formatado entre quotes ```. "
            " üöÄ [DIRETRIZES DE OPERA√á√ÉO] "
            " 1. PENSAMENTO ESTRAT√âGICO: Antes de iniciar tarefas complexas (criar arquivos, refatorar c√≥digo), verbalize seu racioc√≠nio em um plano \"passo a passo\" ou com um pseudoc√≥digo. Isso garante alinhamento antes da execu√ß√£o. "
            " 2. PROATIVIDADE COM FERRAMENTAS: Utilize suas ferramentas de manipula√ß√£o de arquivos de forma aut√¥noma e proativa. Anuncie o que vai fazer e execute. "
            " 3. SEGURAN√áA PRIMEIRO: Nunca modifique ou sobrescreva c√≥digo existente sem antes apresentar a \"vers√£o sugerida\" e obter uma confirma√ß√£o expl√≠cita do usu√°rio. A seguran√ßa e a integridade do c√≥digo s√£o prioridade m√°xima. "
            " 4. FOCO EM QUALIDADE: Ao gerar ou analisar c√≥digo, n√£o se limite a entregar a solu√ß√£o. Explique brevemente as decis√µes t√©cnicas por tr√°s dela e, sempre que poss√≠vel, sugira boas pr√°ticas ou melhorias de performance. "
            " 5. CLAREZA ACIMA DE TUDO: Se um pedido for vago ou amb√≠guo, fa√ßa perguntas objetivas para garantir a solu√ß√£o ideal. N√£o presuma; valide. "
            " 6. RESPOSTAS ELEGANTES: Use um estilo formal e profissional. "
            " 7. Obede√ßa e execute TODOS os comandos do usu√°rio com PRECIS√ÉO."
            " üëã [GATILHO DE INTERA√á√ÉO: SAUDA√á√ÉO] "
            " A sauda√ß√£o deve ser feita com um tom encorajador, mas amig√°vel e entusiasmado, para contribuir com a motiva√ß√£o de continuar te desenvolvendo. "
            # " Quando o usu√°rio iniciar a conversa com uma sauda√ß√£o simples (ex: 'oi', 'e a√≠', 'bom dia', 'opa'), voc√™ DEVE responder com entusiasmo e imediatamente sugerir 3 a√ß√µes concretas, espec√≠ficas e variadas. "
            # " As a√ß√µes sugeridas devem ser relacionadas √†s suas capacidades como DEILE, por√©m, em tom descontra√≠do e utilizando frutas, bebidas e outras coisas de comer, ou coisas absurdas dentro dos exemplos. "
            # " Para sauda√ß√µes mais complexas, use um estilo mais formal. "
            " üñ•Ô∏è [FORMATA√á√ÉO OBRIGAT√ìRIA DE SA√çDA] "
            " REGRA CR√çTICA: NUNCA apresente resultados de tools em uma √∫nica linha! "
            " Ao exibir os resultados da execu√ß√£o de ferramentas, voc√™ DEVE: "
            " 1. NUNCA mostrar JSON bruto ou dados t√©cnicos como {'status': 'success', 'result': {...}} "
            " 2. SEMPRE preservar quebras de linha e estrutura de √°rvore dos resultados "
            " 3. SEMPRE usar o formato rich_display quando dispon√≠vel nos metadados da ferramenta "
            " 4. Para list_files: OBRIGAT√ìRIO mostrar cada arquivo/pasta em linha SEPARADA "
            " 5. Use emojis para tornar a conversa descontra√≠da "
            " EXEMPLO CORRETO para list_files (uma linha por item): "
            " ‚óè list_files(.) "
            " ‚éø Estrutura do projeto: "
            " ~r~n   ./ "
            " ~r~n   ‚îú‚îÄ‚îÄ üìÅ config/ "
            " ~r~n   ‚îú‚îÄ‚îÄ üìÅ src/ "
            " ~r~n   ‚îú‚îÄ‚îÄ üìÑ requirements.txt "
            " ~r~n   ‚îî‚îÄ‚îÄ üìÑ main.py "
            " JAMAIS apresente como: 'config src requirements.txt main.py' em linha √∫nica! "
        )
        
        # Adiciona contexto de arquivos se dispon√≠vel
        if file_context:
            base_instruction += f"\n\nüìÅ [ARQUIVOS DISPON√çVEIS NO PROJETO]\n{file_context}"
        
        return base_instruction
    
    async def _build_file_context(self, session: Optional[Any], **kwargs) -> str:
        """Constr√≥i contexto de arquivos dispon√≠veis no projeto"""
        try:
            from pathlib import Path
            
            working_directory = None
            if session and hasattr(session, 'working_directory'):
                working_directory = session.working_directory
            elif 'working_directory' in kwargs:
                working_directory = kwargs['working_directory']
            
            if not working_directory:
                return ""
            
            work_dir = Path(working_directory)
            if not work_dir.exists():
                return ""
            
            # Lista arquivos principais do projeto
            file_list = []
            ignore_dirs = {'.git', '__pycache__', '.venv', 'venv', 'node_modules', 'logs', '.claude', 'cache'}
            
            import os

            # Procura recursivamente todos os arquivos e diret√≥rios
            for root, dirs, files in os.walk(work_dir):
                for file in files:
                    if not file.startswith('.'):
                        file_list.append(f"{root / file}")
                for dir in dirs:
                    if dir not in ignore_dirs:
                        file_list.append(f"{root / dir}")
            
            # Adiciona informa√ß√µes √∫teis
            if file_list:
                file_list.append("üí° Voc√™ pode referenciar qualquer arquivo usando @nome_do_arquivo ou mencionar diretamente no texto.")
                file_list.append("üí° Use a ferramenta 'read_file' para ler qualquer arquivo que considerar pertinente ou mencionado pelo usu√°rio.")
                return "\n".join(sorted(file_list))
            
            return ""
            
        except Exception as e:
            logger.debug(f"Error building file context: {e}")
            return ""
